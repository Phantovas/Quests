#define LedPin 7      //говорим компилятору чтобы заменил все LedPin на 7, нет смысла для этого заводить переменную
#define TickCount 50  //число опросов одного пина

const int sumBtn = 51; 
const int btnPin[sumBtn] = {2,3,4,5,6,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53 }; 
int count = 0;
//вообще по алгоритму состояния не нужны, ну или на крайняк объявить их как bool (1 байт тоже конечно расточительство, можно пакованной структурой сделать,
//но в данном контексте не обязательно), а вот нафига int (2 байта) под состояние кнопки не понятно
bool currentState;

void setup() {
	pinMode(LedPin, OUTPUT);
	for (int i=0; i<sumBtn; i++)  
		pinMode(btnPin[i], INPUT);
}

void loop() {
  count = 0;
  //читаем состояния, если 1 то накручиваем счетчик
	for (int i = 0; i < sumBtn; i++){
    //первоначальное состояние пина
    currentState = digitalRead(btnPin[i]);
    //если пин активен, то переходим к определению не дребезжит ли он, иначе не тратим на него время
		if (currentState) {
    //опрашиваем пин TickCount раз
      for (int j = 0; j < TickCount; j++) {
        //читаем состояние пина
        currentState = digitalRead(btnPin[i]);
        //если хоть раз неактивна - то это дребезг, выходим из цикла
        if (!currentState)
          break;
      }
      //приращиваем или не приращиваем в зависимости от условия 
      count += (int)(currentState);
    }
	}  
  //вывод результатов
  //используем функцию map для наложения диапазонов
  count = map(count, 0, sumBtn, 0, 255);
  //сигнализация
  analogWrite(LedPin, count);
}
